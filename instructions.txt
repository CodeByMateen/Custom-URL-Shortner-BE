a model
In the high-level design, everything is stored in a hash table. This is a good starting point; however, this approach is not feasible for real-world systems as memory resources are limited and expensive. A better option is to store <shortURL, longURL> mapping in a relational database. Figure 4 shows a simple database table design. The simplified version of the table contains 3 columns: id, shortURL, longURL.

Image represents a simplified relational database table schema, likely for a URL shortening service.  The table is named 'url' and contains three columns. The first column, labeled 'PK' (Primary Key), indicates that the 'id' column serves as the unique identifier for each row.  The 'id' column itself presumably holds a unique integer representing each shortened URL entry. The second column, 'shortURL', stores the shortened URL string, and the third column, 'longURL', stores the corresponding original, longer URL string.  No information flows between the columns; rather, each row represents a single mapping between a short URL and its long URL counterpart. The table structure suggests that given a shortURL, one can retrieve the corresponding longURL, and vice-versa, using the 'id' as the primary key for efficient lookups.
Figure 4
Hash function
Hash function is used to hash a long URL to a short URL, also known as hashValue.

Hash value length
The hashValue consists of characters from [0-9, a-z, A-Z], containing 10 + 26 + 26 = 62 possible characters. To figure out the length of hashValue, find the smallest n such that 62^n ≥ 365 billion. The system must support up to 365 billion URLs based on the back of the envelope estimation. Table 1 shows the length of hashValue and the corresponding maximal number of URLs it can support.

n	Maximal number of URLs
1	62^1 = 62
2	62^2 = 3,844
3	62^3 = 238,328
4	62^ 4 = 14,776,336
5	62^5 = 916,132,832
6	62^6 = 56,800,235,584
7	62^7 = 3,521,614,606,208 = ~3.5 trillion
8	62^8 = 218,340,105,584,896
Table 1

When n = 7, 62 ^ n = ~3.5 trillion, 3.5 trillion is more than enough to hold 365 billion URLs, so the length of hashValue is 7.

We will explore two types of hash functions for a URL shortener. The first one is “hash + collision resolution”, and the second one is “base 62 conversion.” Let us look at them one by one.

Hash + collision resolution
To shorten a long URL, we should implement a hash function that hashes a long URL to a 7-character string. A straightforward solution is to use well-known hash functions like CRC32, MD5, or SHA-1. The following table compares the hash results after applying different hash functions on this URL:
https://en.wikipedia.org/wiki/Systems_design

Hash function	Hash value (Hexadecimal)
CRC32	5cb54054
MD5	5a62509a84df9ee03fe1230b9df8b84e
SHA-1	0eeae7916c06853901d9ccbefbfcaf4de57ed85b
Table 2

As shown in Table 2, even the shortest hash value (from CRC32) is too long (more than 7 characters). How can we make it shorter?

The first approach is to collect the first 7 characters of a hash value; however, this method can lead to hash collisions. To resolve hash collisions, we can recursively append a new predefined string until no more collision is discovered. This process is explained in Figure 5.

Image represents a flowchart depicting the process of URL shortening.  It begins with a green circle labeled 'start,' which initiates the process.  An arrow leads to a light-blue rectangle labeled 'input: longURL,' representing the input of a long URL. This long URL then flows to a light-blue rectangle labeled 'hash function,' where a hashing algorithm is applied to generate a shortened URL. The output, 'shortURL,' is shown in another light-blue rectangle.  This short URL then enters a diamond-shaped decision node labeled 'exist in DB?', checking if the short URL already exists in a database (DB). If 'yes' (a collision), an arrow points to a light-blue rectangle labeled 'longURL + predefi..,' indicating that the process might involve appending a predefined string to the long URL and repeating the hashing process. If 'no,' an arrow leads to a light-blue rectangle labeled 'save to DB,' where the short URL and its corresponding long URL are stored in the database. Finally, an arrow leads from 'save to DB' to a green circle labeled 'end,' signifying the completion of the process.  The arrows indicate the flow of data and control throughout the system.
Figure 5
This method can eliminate collision; however, it is expensive to query the database to check if a shortURL exists for every request. A technique called bloom filters [2] can improve performance. A bloom filter is a space-efficient probabilistic technique to test if an element is a member of a set. Refer to the reference material [2] for more details.

Base 62 conversion
Base conversion is another approach commonly used for URL shorteners. Base conversion helps to convert the same number between its different number representation systems. Base 62 conversion is used as there are 62 possible characters for hashValue. Let us use an example to explain how the conversion works: convert 1115710 to base 62 representation (1115710 represents 11157 in a base 10 system).

From its name, base 62 is a way of using 62 characters for encoding. The mappings are: 0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z, where ‘a’ stands for 10, ‘Z’ stands for 61, etc.

1115710 = 2 x 622 + 55 x 621 + 59 x 620 = [2, 55, 59] -> [2, T, X] in base 62 representation. Figure 6 shows the conversation process.

Image represents a diagram illustrating the conversion of a decimal number (11157) into its base-62 representation.  The left side shows a repeated division process.  The number 11157 is repeatedly divided by 62, with the remainders shown on the right (59, 55, and 2).  Each division's quotient becomes the dividend in the next step (11157/62 = 179 remainder 59; 179/62 = 2 remainder 55; 2/62 = 0 remainder 2). The remainders are listed in reverse order to form the base-62 representation ('X T 2'), where 'X' represents 59 and 'T' represents 55. The final remainder is 0, indicating the end of the conversion.  The diagram visually connects each division step with a line, showing the flow of the calculation from the initial decimal number to its base-62 equivalent.
Figure 6
Thus, the short URL is https://tinyurl.com/2TX
Comparison of the two approaches
Table 3 shows the differences of the two approaches.

Hash + collision resolution	Base 62 conversion
Fixed short URL length.	Short URL length is not fixed. It goes up with the ID.
Does not need a unique ID generator.	This option depends on a unique ID generator.
Collision is possible and needs to be resolved.	Collision is not possible because ID is unique.
It’s not possible to figure out the next available short URL because it doesn’t depend on ID.	It is easy to figure out what is the next available short URL if ID increments by 1 for a new entry. This can be a security concern.
Table 3

URL shortening deep dive
As one of the core pieces of the system, we want the URL shortening flow to be logically simple and functional. Base 62 conversion is used in our design. We build the following diagram (Figure 7) to demonstrate the flow.

Image represents a flowchart depicting the process of URL shortening.  It begins with a rectangular box labeled '1. input: longURL,' representing the input of a long URL. An arrow connects this to a diamond-shaped decision box, '2. longURL in DB?', which checks if the long URL already exists in the database (DB).  If 'yes,' an arrow points to a rectangular box, '3. return shortURL,' indicating that the corresponding short URL is returned. If 'no,' an arrow leads to a rectangular box, '4. Generate a ne...', suggesting the generation of a new unique ID. This is followed by a box, '5. Convert ID to...', implying the conversion of this ID into a short URL. Finally, an arrow connects to '6. Save ID, shor...', indicating the saving of both the ID and the short URL into the database.  The entire flow is sequential, with each step dependent on the previous one, culminating in either returning an existing short URL or generating and saving a new one.
Figure 7
longURL is the input.

The system checks if the longURL is in the database.

If it is, it means the longURL was converted to shortURL before. In this case, fetch the shortURL from the database and return it to the client.

If not, the longURL is new. A new unique ID (primary key) Is generated by the unique ID generator.

Convert the ID to shortURL with base 62 conversion.

Create a new database row with the ID, shortURL, and longURL.

To make the flow easier to understand, let us look at a concrete example.

Assuming the input longURL is: https://en.wikipedia.org/wiki/Systems_design

Unique ID generator returns ID: 2009215674938.

Convert the ID to shortURL using the base 62 conversion. ID (2009215674938) is converted to “zn9edcu”.

Save ID, shortURL, and longURL to the database as shown in Table 4.

id	shortURL	longURL
2009215674938	zn9edcu	https://en.wikipedia.org/wiki/Systems_design
Table 4

The distributed unique ID generator is worth mentioning. Its primary function is to generate globally unique IDs, which are used for creating shortURLs. In a highly distributed environment, implementing a unique ID generator is challenging. Luckily, we have already discussed a few solutions in the “Design A Unique ID Generator in Distributed Systems” chapter. You can refer back to it to refresh your memory.

URL redirecting deep dive
Figure 8 shows the detailed design of the URL redirecting. As there are more reads than writes, <shortURL, longURL> mapping is stored in a cache to improve performance.

Image represents a simplified system architecture diagram illustrating a user's request for a shortened URL and its resolution.  A user (represented by icons of a laptop and a mobile phone) initiates a GET request (1) to the shortened URL 'https://tinyurl.com/zn9edcu'. This request is directed to a load balancer (2), which distributes the traffic across multiple web servers. The web servers then return the long URL 'https://en.wikipedia.org/wiki/Systems_design' (5) to the user.  The web servers are connected to a cache (3) for faster access to frequently requested data and a database (4) for persistent storage of information.  The numbered arrows (1-5) indicate the flow of the request and response, showing the interaction between the user, load balancer, web servers, cache, and database.
Figure 8
The flow of URL redirecting is summarized as follows:

A user clicks a short URL link: https://tinyurl.com/zn9edcu

The load balancer forwards the request to web servers.

If a shortURL is already in the cache, return the longURL directly.

If a shortURL is not in the cache, fetch the longURL from the database. If it is not in the database, it is likely a user entered an invalid shortURL.

The longURL is returned to the user.